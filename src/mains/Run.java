package mains;

import brightbodies.BrightBody;
import brightbodies.BrightBodyList;
import filtering.MobilityFilter;
import filtering.ReferenceMobilityFilter;
import locating.BinaryLocator;
import locating.Locator;
import nom.tam.fits.Fits;
import preprocessing.K2Preprocessor;
import preprocessing.Preprocessor;
import locating.BinaryLocator.ThresholdType;
import filtering.ReferenceMobilityFilter.ReferenceBodyDetectionMethod;

import java.io.File;

/**
 * @author Jonathan Zwiebel
 * @version February 3rd, 2016
 *
 * TODO: Consider the data output in a fifth macro step
 */
public class Run {
    /**
     * Main method to be run for program execution
     * @param args Location, Initial locating threshold, Similarity threshold, Reference locating threshold, Timestamp
     * TODO: Make mean passable by more than just -1
     */
    public static void main(String[] args) {
        String data_location = args[0];
        float detection_threshold = Float.parseFloat(args[1]);
        float similarity_threshold = Float.parseFloat(args[2]);
        float reference_frame_detection_threshold = Float.parseFloat(args[3]);
        int timestamp = Integer.parseInt(args[4]);

        try {
            System.out.println("Preprocessing");
            Preprocessor preprocessor = new K2Preprocessor(new Fits(new File(data_location)));
            float[][][] data = preprocessor.read();

            Locator locator;
            if(detection_threshold == -1) {
                System.out.println("Locating with mean threshold");
                locator = new BinaryLocator(data, ThresholdType.MEAN);
            }
            else {
                System.out.println("Locating with given threshold: " + detection_threshold);
                locator = new BinaryLocator(data, ThresholdType.GIVEN, detection_threshold);
            }
            locator.initialize();
            BrightBodyList[] bodies = locator.locate();


            MobilityFilter filter;
            if(reference_frame_detection_threshold == -1) {
                System.out.println("Filtering with sim thresh of " + similarity_threshold + " and mean threshold reference image");
                filter = new ReferenceMobilityFilter(bodies, data, similarity_threshold, ReferenceBodyDetectionMethod.MEAN);
            }
            else {
                System.out.println("Filtering with sim thresh of " + similarity_threshold + " and given threshold reference image: " + reference_frame_detection_threshold);
                filter = new ReferenceMobilityFilter(bodies, data, similarity_threshold, ReferenceBodyDetectionMethod.ABSOLUTE, reference_frame_detection_threshold);
            }
            BrightBodyList[][] filtered_bodies = filter.filter();
            BrightBodyList[] immobile_bodies = filtered_bodies[MobilityFilter.IMMOBILE_INDEX];
            BrightBodyList[] mobile_bodies = filtered_bodies[MobilityFilter.MOBILE_INDEX];

            printSimpleDetectionStatsTimestamped(mobile_bodies, immobile_bodies, timestamp);
        }
        catch(Exception e ) {
            e.printStackTrace();
        }
    }

    /**
     * Prints a simplified set of data about mobile and immobile locating and filtering for a given timestamp
     *
     * @param mobile_bodies the BrightBodyList[] of mobile bright bodies generated by a mobility filter
     * @param immobile_bodies the BrightBodyList[] of immobile bright bodies generated by a mobility filter
     * @param timestamp the timestamp in the data to output the data
     */
    public static void printSimpleDetectionStatsTimestamped(BrightBodyList[] mobile_bodies, BrightBodyList[] immobile_bodies, int timestamp) {
        System.out.println("In frame " + timestamp);
        int mob_count = mobile_bodies[timestamp].size();
        int imob_count = immobile_bodies[timestamp].size();
        int total_count = mob_count + imob_count;
        System.out.println("Total: " + total_count);
        System.out.println("Immobile: " + imob_count);
        System.out.println("Mobile: " + mob_count);
        System.out.println("Mobile Rate: " + mob_count / (float) total_count);
        System.out.print("Mean Mobile Area: ");
        float mobile_area_sum = 0.0f;
        for(BrightBody b : mobile_bodies[timestamp]) {
            mobile_area_sum += b.area;
        }
        System.out.print(mobile_area_sum / mob_count);


        System.out.print("\nMean Mobile Size: ");
        float mobile_size_sum = 0.0f;
        for(BrightBody b : mobile_bodies[timestamp]) {
            mobile_size_sum += b.body.length;
        }
        System.out.println(mobile_size_sum / mob_count);
    }
}