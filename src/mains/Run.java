package mains;

import brightbodies.BrightBody;
import brightbodies.BrightBodyList;
import filtering.MobilityFilter;
import filtering.ReferenceMobilityFilter;
import helper.FitsHelper;
import locating.BinaryLocator;
import locating.Locator;
import mask.BinaryImageMask;
import nom.tam.fits.Fits;
import nom.tam.fits.FitsException;
import preprocessing.K2Preprocessor;
import preprocessing.Preprocessor;
import locating.BinaryLocator.ThresholdType;
import filtering.ReferenceMobilityFilter.ReferenceBodyDetectionMethod;

import java.io.File;
import java.io.IOException;

/**
 * @author Jonathan Zwiebel
 * @version February 3rd, 2016
 *
 * TODO: Consider the data output in a fifth macro step
 */
public class Run {
    /**
     * Main method to be run for program execution
     * @param args Location, Initial locating threshold, Similarity threshold, Reference locating threshold, Timestamp
     * TODO: Make mean passable by more than just -1
     */
    public static void main(String[] args) {
        String data_location = args[0];
        float detection_threshold = Float.parseFloat(args[1]);
        float mean_shifted_detection_threshold_shift = Float.parseFloat(args[2]);
        float similarity_threshold = Float.parseFloat(args[3]);
        float reference_frame_detection_threshold = Float.parseFloat(args[4]);
        int timestamp = Integer.parseInt(args[5]);
        String mask_location = args[6];

        long start_time = System.currentTimeMillis();

        try {
            System.out.println("Preprocessing");
            Preprocessor preprocessor = new K2Preprocessor(new Fits(new File(data_location)));
            float[][][] data = preprocessor.read();

            Locator locator;
            if(detection_threshold == -1) {
                System.out.println("Locating with mean threshold");
                locator = new BinaryLocator(data, ThresholdType.MEAN);
            }
            else if(detection_threshold == -2) {
                System.out.println("Locating with mean threshold and shift of " + mean_shifted_detection_threshold_shift);
                locator =  new BinaryLocator(data, ThresholdType.MEAN_SHIFTED, mean_shifted_detection_threshold_shift);
          }
            else {
                System.out.println("Locating with given threshold: " + detection_threshold);
                locator = new BinaryLocator(data, ThresholdType.GIVEN, detection_threshold);
            }
            locator.initialize();
            BrightBodyList[] bodies = locator.locate();


            MobilityFilter filter;
            if(reference_frame_detection_threshold == -1) {
                System.out.println("Filtering with similarity threshold of " + similarity_threshold + " and mean threshold reference image");
                filter = new ReferenceMobilityFilter(bodies, data, similarity_threshold, ReferenceBodyDetectionMethod.MEAN);
            }
            else {
                System.out.println("Filtering with similarity threshold of " + similarity_threshold + " and given threshold reference image: " + reference_frame_detection_threshold);
                filter = new ReferenceMobilityFilter(bodies, data, similarity_threshold, ReferenceBodyDetectionMethod.ABSOLUTE, reference_frame_detection_threshold);
            }
            BrightBodyList[][] filtered_bodies = filter.filter();
            BrightBodyList[] immobile_bodies = filtered_bodies[MobilityFilter.IMMOBILE_INDEX];
            BrightBodyList[] mobile_bodies = filtered_bodies[MobilityFilter.MOBILE_INDEX];

            printSimpleDetectionStatsTimestamped(mobile_bodies, immobile_bodies, timestamp);
            printSimpleDetectionDataTimestamped(mobile_bodies, immobile_bodies, timestamp);
            writeBinaryImageMask(mask_location + detection_threshold + ".fits", data[timestamp], detection_threshold);
        }
        catch(Exception e ) {
            e.printStackTrace();
        }

        long end_time = System.currentTimeMillis();
        System.out.println("Run time: " + (end_time - start_time) + " milliseconds");
    }

    /**
     * Prints a simplified set of data about mobile and immobile locating and filtering for a given timestamp
     *
     * @param mobile_bodies the BrightBodyList[] of mobile bright bodies generated by a mobility filter
     * @param immobile_bodies the BrightBodyList[] of immobile bright bodies generated by a mobility filter
     * @param timestamp the timestamp of which to output the data
     */
    public static void printSimpleDetectionStatsTimestamped(BrightBodyList[] mobile_bodies, BrightBodyList[] immobile_bodies, int timestamp) {
        int mob_count = mobile_bodies[timestamp].size();
        int imob_count = immobile_bodies[timestamp].size();
        int total_count = mob_count + imob_count;
        System.out.println("\nTotal: " + total_count);
        System.out.println("Immobile: " + imob_count);
        System.out.println("Mobile: " + mob_count);
        System.out.println("Mobile Rate: " + mob_count / (float) total_count);
        System.out.print("Mean Mobile Area: ");
        float mobile_area_sum = 0.0f;
        for(BrightBody b : mobile_bodies[timestamp]) {
            mobile_area_sum += b.area;
        }
        System.out.print(mobile_area_sum / mob_count);


        System.out.print("\nMean Mobile Size: ");
        float mobile_size_sum = 0.0f;
        for(BrightBody b : mobile_bodies[timestamp]) {
            mobile_size_sum += b.body.length;
        }
        System.out.println(mobile_size_sum / mob_count + "\n");
    }

    /**
     * Prints the set of bright bodies (data) in the BrightBodyList[]s generated by a filter for a given timestamp
     *
     * @param mobile_bodies the BrightBodyList[] of mobile bright bodies generated by a mobility filter
     * @param immobile_bodies the BrightBodyList[] of immobile bright bodies generated by a mobility filter
     * @param timestamp the timestamp of which to output the data
     */
    public static void printSimpleDetectionDataTimestamped(BrightBodyList[] mobile_bodies, BrightBodyList[] immobile_bodies, int timestamp) {
        System.out.println("\nMobile:\n" + mobile_bodies[timestamp]);
        System.out.println("Immobile:\n" + immobile_bodies[timestamp] + "\n");
    }


    /**
     * Writes a quickly generated BinaryImageMask to a fits file to make analysis of detected patterns easier
     *
     * @param location location in the filepath to write to
     * @param data floating point astro-data
     * @param threshold threshold for the BinaryImageMask
     * @throws FitsException
     * @throws IOException
     *
     * TODO[Minor]: Make this work with mean
     */
    public static void writeBinaryImageMask(String location, float[][] data, float threshold) throws FitsException, IOException {
        BinaryImageMask mask_generator = new BinaryImageMask(data);
        boolean[][] mask = mask_generator.mask(threshold);
        FitsHelper.write2DImage(mask, location);
    }
}